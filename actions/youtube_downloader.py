#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
YouTube Downloader Action
Download video t·ª´ YouTube v√† t·ª± ƒë·ªông t·∫°o content cho TikTok
"""

import os
import re
import json
import tempfile
from datetime import datetime
from .base_action import BaseAction
from .content_generator import TikTokContentGenerator


class YouTubeDownloaderAction(BaseAction):
    """Action ƒë·ªÉ download video t·ª´ YouTube v√† t·∫°o TikTok content"""
    
    def __init__(self):
        super().__init__()
        self.content_generator = TikTokContentGenerator()
        
        # Supported video qualities
        self.quality_options = {
            "1": {"name": "720p (Recommended)", "format": "best[height<=720]"},
            "2": {"name": "1080p (High Quality)", "format": "best[height<=1080]"},
            "3": {"name": "480p (Fast Download)", "format": "best[height<=480]"},
            "4": {"name": "Best Available", "format": "best"},
            "5": {"name": "Audio Only (MP3)", "format": "bestaudio"}
        }
    
    def check_dependencies(self):
        """Ki·ªÉm tra c√°c dependencies c·∫ßn thi·∫øt"""
        try:
            import yt_dlp
            return True
        except ImportError:
            print("‚ùå Thi·∫øu th∆∞ vi·ªán yt-dlp!")
            print("üìã C√†i ƒë·∫∑t b·∫±ng l·ªánh: pip install yt-dlp")
            return False
    
    def extract_video_id(self, url):
        """Extract video ID t·ª´ YouTube URL"""
        patterns = [
            r'[?&]v=([^&\n?#]+)',  # ?v= ho·∫∑c &v=
            r'youtu\.be/([^&\n?#]+)',  # youtu.be/VIDEO_ID
            r'youtube\.com/embed/([^&\n?#]+)',  # embed/VIDEO_ID
        ]
        
        for pattern in patterns:
            match = re.search(pattern, url)
            if match:
                video_id = match.group(1)
                print(f"üéØ Extracted video ID: {video_id}")
                return video_id
        
        return None
    
    def clean_video_url(self, url):
        """Clean URL ƒë·ªÉ ch·ªâ l·∫•y video, b·ªè playlist parameters"""
        video_id = self.extract_video_id(url)
        
        if video_id:
            # T·∫°o clean URL ch·ªâ c√≥ video ID
            clean_url = f"https://www.youtube.com/watch?v={video_id}"
            print(f"üßπ Clean URL: {clean_url}")
            return clean_url
        
        return url
    
    def validate_youtube_url(self, url):
        """Validate YouTube URL v√† ph√°t hi·ªán playlist"""
        youtube_patterns = [
            r'(https?://)?(www\.)?(youtube\.com/watch\?v=|youtu\.be/|youtube\.com/embed/)',
            r'(https?://)?(www\.)?youtube\.com/.*[?&]v=',
            r'(https?://)?(www\.)?youtu\.be/'
        ]
        
        # Ki·ªÉm tra playlist URL
        playlist_patterns = [
            r'(https?://)?(www\.)?youtube\.com/playlist\?list=',
        ]
        
        # Ki·ªÉm tra n·∫øu l√† playlist URL thu·∫ßn t√∫y (kh√¥ng c√≥ video ID)
        for pattern in playlist_patterns:
            if re.search(pattern, url) and 'v=' not in url:
                print("‚ö†Ô∏è Ph√°t hi·ªán Playlist URL thu·∫ßn t√∫y!")
                print("üí° Ch·ª©c nƒÉng n√†y ch·ªâ h·ªó tr·ª£ single video")
                print("üîó Vui l√≤ng s·ª≠ d·ª•ng URL c·ªßa 1 video c·ª• th·ªÉ")
                print("üìã V√≠ d·ª•: https://www.youtube.com/watch?v=VIDEO_ID")
                return False
        
        # Ki·ªÉm tra video URL h·ª£p l·ªá
        for pattern in youtube_patterns:
            if re.search(pattern, url):
                return True
        
        return False
    
    def get_video_info(self, url):
        """L·∫•y th√¥ng tin video t·ª´ YouTube URL v·ªõi logging chi ti·∫øt"""
        try:
            import yt_dlp
            
            print("üîç ƒêang k·∫øt n·ªëi ƒë·∫øn YouTube...")
            print("üì° ƒêang g·ª≠i request...")
            
            # Clean URL tr∆∞·ªõc khi x·ª≠ l√Ω
            original_url = url
            clean_url = self.clean_video_url(url)
            
            if clean_url != original_url:
                print("üßπ ƒê√£ clean URL (lo·∫°i b·ªè playlist parameters)")
                print(f"   Original: {original_url}")
                print(f"   Clean: {clean_url}")
                url = clean_url
            
            # Extract video ID ƒë·ªÉ verify
            video_id = self.extract_video_id(url)
            if video_id:
                print(f"üéØ Video ID: {video_id}")
            else:
                print("‚ö†Ô∏è Kh√¥ng extract ƒë∆∞·ª£c video ID")
            
            ydl_opts = {
                'quiet': True,
                'no_warnings': True,
                'extract_flat': False,  # ƒê·∫£m b·∫£o extract full info
                'noplaylist': True,     # QUAN TR·ªåNG: Ch·ªâ l·∫•y video, kh√¥ng l·∫•y playlist
            }
            
            print("‚è≥ ƒêang ch·ªù ph·∫£n h·ªìi t·ª´ server...")
            
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                print("üîÑ ƒêang extract metadata cho video c·ª• th·ªÉ...")
                info = ydl.extract_info(url, download=False)
                
                # Debug: In type c·ªßa response
                response_type = info.get('_type', 'video')
                print(f"üîç Response type: {response_type}")
                
                # Ki·ªÉm tra n·∫øu v·∫´n l√† playlist
                if response_type == 'playlist':
                    print("‚ùå V·∫´n nh·∫≠n ƒë∆∞·ª£c playlist thay v√¨ video!")
                    print("üîÑ Th·ª≠ force extract video...")
                    
                    # Th·ª≠ l·∫ßn n·ªØa v·ªõi video ID tr·ª±c ti·∫øp
                    if video_id:
                        video_url = f"https://www.youtube.com/watch?v={video_id}"
                        info = ydl.extract_info(video_url, download=False)
                        response_type = info.get('_type', 'video')
                        print(f"üîÑ Retry response type: {response_type}")
                    
                    if response_type == 'playlist':
                        print("‚ùå Kh√¥ng th·ªÉ l·∫•y th√¥ng tin video c·ª• th·ªÉ")
                        return None
                
                print("‚úÖ Nh·∫≠n ƒë∆∞·ª£c d·ªØ li·ªáu video t·ª´ YouTube")
                print("üîç ƒêang parse th√¥ng tin video...")
                
                # Parse t·ª´ng th√¥ng tin v·ªõi validation t·ªët h∆°n
                title = info.get('title', '').strip()
                if not title:
                    # Th·ª≠ l·∫•y t·ª´ c√°c field kh√°c
                    title = info.get('fulltitle', '') or info.get('display_title', '') or 'Unknown Title'
                
                print(f"   üìù Title: {title}")
                
                duration = info.get('duration', 0)
                if duration and duration > 0:
                    duration_str = f"{duration//60}:{duration%60:02d}"
                    print(f"   ‚è±Ô∏è Duration: {duration_str} ({duration} gi√¢y)")
                else:
                    print("   ‚ö†Ô∏è Duration kh√¥ng c√≥ ho·∫∑c = 0")
                    duration = 0
                
                uploader = info.get('uploader', '') or info.get('channel', '') or 'Unknown Channel'
                print(f"   üë§ Channel: {uploader}")
                
                upload_date = info.get('upload_date', '')
                if upload_date and len(upload_date) == 8:
                    formatted_date = f"{upload_date[:4]}-{upload_date[4:6]}-{upload_date[6:8]}"
                    print(f"   üìÖ Upload date: {formatted_date}")
                else:
                    print(f"   üìÖ Upload date: {upload_date or 'Unknown'}")
                
                view_count = info.get('view_count', 0) or 0
                print(f"   üëÄ Views: {view_count:,}")
                
                description = info.get('description', '') or ''
                desc_length = len(description)
                print(f"   üìù Description: {desc_length} characters")
                if desc_length > 0:
                    # Preview description
                    desc_preview = description[:100].replace('\n', ' ') + '...' if len(description) > 100 else description
                    print(f"       Preview: {desc_preview}")
                
                tags = info.get('tags', []) or []
                print(f"   üè∑Ô∏è Tags: {len(tags)} tags")
                if tags:
                    print(f"       Preview: {', '.join(tags[:5])}{'...' if len(tags) > 5 else ''}")
                
                thumbnail = info.get('thumbnail', '')
                print(f"   üñºÔ∏è Thumbnail: {'Available' if thumbnail else 'N/A'}")
                
                # Verify video ID
                extracted_id = info.get('id', '') or video_id
                print(f"   üÜî Confirmed Video ID: {extracted_id}")
                
                # T·∫°o video_info object
                video_info = {
                    'title': title,
                    'duration': duration,
                    'uploader': uploader,
                    'upload_date': upload_date,
                    'view_count': view_count,
                    'description': description,
                    'tags': tags,
                    'thumbnail': thumbnail,
                    'webpage_url': f"https://www.youtube.com/watch?v={extracted_id}",
                    'video_id': extracted_id
                }
                
                print("‚úÖ Ho√†n th√†nh parse th√¥ng tin video")
                print(f"üìä D·ªØ li·ªáu h·ª£p l·ªá: {len([k for k, v in video_info.items() if v])} tr∆∞·ªùng")
                
                # Validation cu·ªëi c√πng
                if not title or title == 'Unknown Title':
                    print("‚ùå Title kh√¥ng h·ª£p l·ªá")
                    return None
                
                if duration == 0:
                    print("‚ö†Ô∏è Duration = 0, c√≥ th·ªÉ c√≥ v·∫•n ƒë·ªÅ v·ªõi video")
                    # V·∫´n ti·∫øp t·ª•c nh∆∞ng c·∫£nh b√°o
                
                return video_info
                
        except Exception as e:
            print(f"‚ùå L·ªói l·∫•y th√¥ng tin video: {e}")
            print("üîç Ki·ªÉm tra:")
            print("   - URL c√≥ ƒë√∫ng format kh√¥ng?")
            print("   - Video c√≥ public kh√¥ng?")
            print("   - Video c√≥ b·ªã age-restricted kh√¥ng?")
            print("   - K·∫øt n·ªëi internet ·ªïn ƒë·ªãnh kh√¥ng?")
            import traceback
            print(f"üîç Chi ti·∫øt l·ªói: {traceback.format_exc()}")
            return None
    
    def show_quality_menu(self):
        """Hi·ªÉn th·ªã menu ch·ªçn ch·∫•t l∆∞·ª£ng"""
        print("\nüì∫ CH·ªåN CH·∫§T L∆Ø·ª¢NG VIDEO:")
        print("-" * 40)
        for key, option in self.quality_options.items():
            print(f"{key}. {option['name']}")
        print("0. ‚Üê Quay l·∫°i")
        print("-" * 40)
    
    def get_quality_choice(self):
        """L·∫•y l·ª±a ch·ªçn ch·∫•t l∆∞·ª£ng t·ª´ user"""
        while True:
            choice = input("üëâ Ch·ªçn ch·∫•t l∆∞·ª£ng (0-5): ").strip()
            if choice == "0":
                return None
            elif choice in self.quality_options:
                return choice
            else:
                print("‚ùå L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá! Vui l√≤ng ch·ªçn t·ª´ 0-5.")
    
    def download_video(self, url, output_folder, quality_format, video_info):
        """Download video t·ª´ YouTube v·ªõi progress logging chi ti·∫øt"""
        try:
            import yt_dlp
            
            # S·ª≠ d·ª•ng clean URL cho download
            clean_url = self.clean_video_url(url)
            
            # T·∫°o t√™n file an to√†n
            safe_title = re.sub(r'[<>:"/\\|?*]', '_', video_info['title'])
            safe_title = safe_title[:100]  # Gi·ªõi h·∫°n ƒë·ªô d√†i
            
            print("\n" + "="*60)
            print("üöÄ B·∫ÆT ƒê·∫¶U QU√Å TR√åNH DOWNLOAD")
            print("="*60)
            print(f"üì∫ Video: {video_info['title']}")
            print(f"üë§ K√™nh: {video_info['uploader']}")
            print(f"‚è±Ô∏è Th·ªùi l∆∞·ª£ng: {video_info['duration']} gi√¢y")
            print(f"üëÄ L∆∞·ª£t xem: {video_info['view_count']:,}")
            print(f"üéØ Ch·∫•t l∆∞·ª£ng: {quality_format}")
            print(f"üìÅ ƒê√≠ch: {output_folder}")
            print(f"üîó URL: {clean_url}")  # Show clean URL
            print("-"*60)
            
            # Progress hook function
            def progress_hook(d):
                if d['status'] == 'downloading':
                    if 'total_bytes' in d and d['total_bytes']:
                        percent = (d['downloaded_bytes'] / d['total_bytes']) * 100
                        speed = d.get('speed', 0)
                        eta = d.get('eta', 0)
                        
                        # Format speed
                        if speed:
                            if speed > 1024*1024:
                                speed_str = f"{speed/(1024*1024):.1f}MB/s"
                            elif speed > 1024:
                                speed_str = f"{speed/1024:.1f}KB/s"
                            else:
                                speed_str = f"{speed:.0f}B/s"
                        else:
                            speed_str = "N/A"
                        
                        # Format ETA
                        if eta:
                            eta_min = eta // 60
                            eta_sec = eta % 60
                            eta_str = f"{eta_min}:{eta_sec:02d}"
                        else:
                            eta_str = "N/A"
                        
                        # Progress bar
                        bar_length = 30
                        filled_length = int(bar_length * percent / 100)
                        bar = '‚ñà' * filled_length + '‚ñë' * (bar_length - filled_length)
                        
                        print(f"\rüì• Download: [{bar}] {percent:.1f}% | {speed_str} | ETA: {eta_str}", end='', flush=True)
                    
                    elif 'total_bytes_estimate' in d and d['total_bytes_estimate']:
                        percent = (d['downloaded_bytes'] / d['total_bytes_estimate']) * 100
                        print(f"\rüì• Download: {percent:.1f}% (∆∞·ªõc t√≠nh)", end='', flush=True)
                    else:
                        # Kh√¥ng c√≥ th√¥ng tin t·ªïng size
                        downloaded_mb = d['downloaded_bytes'] / (1024*1024)
                        print(f"\rüì• Download: {downloaded_mb:.1f}MB", end='', flush=True)
                
                elif d['status'] == 'finished':
                    print(f"\n‚úÖ Download ho√†n th√†nh: {os.path.basename(d['filename'])}")
                    print(f"üìä K√≠ch th∆∞·ªõc file: {os.path.getsize(d['filename'])/(1024*1024):.1f}MB")
            
            # Thi·∫øt l·∫≠p yt-dlp options v·ªõi clean URL
            ydl_opts = {
                'format': quality_format,
                'outtmpl': os.path.join(output_folder, f"{safe_title}.%(ext)s"),
                'writeinfojson': True,  # L∆∞u metadata
                'writesubtitles': True,  # Download subtitles n·∫øu c√≥
                'writeautomaticsub': True,  # Download auto-generated subtitles
                'subtitleslangs': ['vi', 'en'],  # Vietnamese v√† English subtitles
                'ignoreerrors': True,
                'progress_hooks': [progress_hook],  # Progress tracking
                'noplaylist': True,  # QUAN TR·ªåNG: Ch·ªâ download video, kh√¥ng download playlist
            }
            
            print("üîç ƒêang ph√¢n t√≠ch video v√† chu·∫©n b·ªã download...")
            
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                print("üì° K·∫øt n·ªëi ƒë·∫øn YouTube...")
                print("üéØ T√¨m th·∫•y video, b·∫Øt ƒë·∫ßu download...")
                ydl.download([clean_url])  # S·ª≠ d·ª•ng clean URL
            
            print()  # New line sau progress bar
            print("üîç ƒêang t√¨m file ƒë√£ download...")
            
            # T√¨m file ƒë√£ download
            downloaded_files = []
            for file in os.listdir(output_folder):
                if file.startswith(safe_title) and not file.endswith('.json') and not file.endswith('.vtt'):
                    downloaded_files.append(os.path.join(output_folder, file))
            
            if downloaded_files:
                video_file = downloaded_files[0]  # L·∫•y file ƒë·∫ßu ti√™n
                file_size = os.path.getsize(video_file) / (1024*1024)
                print(f"‚úÖ T√¨m th·∫•y file video: {os.path.basename(video_file)}")
                print(f"üìä K√≠ch th∆∞·ªõc: {file_size:.1f}MB")
                print(f"üìÅ ƒê∆∞·ªùng d·∫´n: {video_file}")
                
                # Ki·ªÉm tra subtitle files
                subtitle_files = [f for f in os.listdir(output_folder) 
                                if f.startswith(safe_title) and (f.endswith('.vtt') or f.endswith('.srt'))]
                if subtitle_files:
                    print(f"üìù T√¨m th·∫•y {len(subtitle_files)} subtitle file(s)")
                    for sub_file in subtitle_files:
                        print(f"   ‚îî‚îÄ‚îÄ {sub_file}")
                
                return video_file
            else:
                print("‚ùå Kh√¥ng t√¨m th·∫•y file video ƒë√£ download")
                return None
                
        except Exception as e:
            print(f"\n‚ùå L·ªói download video: {e}")
            import traceback
            print(f"üîç Chi ti·∫øt l·ªói: {traceback.format_exc()}")
            return None
    
    def process_youtube_url(self, url, output_folder, quality_choice):
        """X·ª≠ l√Ω to√†n b·ªô quy tr√¨nh download v√† t·∫°o content v·ªõi logging chi ti·∫øt"""
        try:
            print("\n" + "="*70)
            print("üé¨ YOUTUBE TO TIKTOK PROCESSOR")
            print("="*70)
            
            # L·∫•y th√¥ng tin video
            print("üîç GIAI ƒêO·∫†N 1: PH√ÇN T√çCH VIDEO")
            print("-"*40)
            print("üì° ƒêang k·∫øt n·ªëi ƒë·∫øn YouTube...")
            print("üîç ƒêang l·∫•y th√¥ng tin video...")
            
            video_info = self.get_video_info(url)
            
            if not video_info:
                print("‚ùå Kh√¥ng th·ªÉ l·∫•y th√¥ng tin video")
                return False
            
            print("‚úÖ L·∫•y th√¥ng tin th√†nh c√¥ng!")
            print("üìã Th√¥ng tin video ƒë√£ thu th·∫≠p:")
            
            # Hi·ªÉn th·ªã th√¥ng tin video v·ªõi logging chi ti·∫øt
            print(f"   üé¨ Ti√™u ƒë·ªÅ: {video_info['title']}")
            print(f"   üë§ K√™nh: {video_info['uploader']}")
            print(f"   ‚è±Ô∏è Th·ªùi l∆∞·ª£ng: {video_info['duration']} gi√¢y ({video_info['duration']//60}:{video_info['duration']%60:02d})")
            print(f"   üëÄ L∆∞·ª£t xem: {video_info['view_count']:,}")
            print(f"   üìÖ Ng√†y t·∫£i l√™n: {video_info.get('upload_date', 'N/A')}")
            print(f"   üè∑Ô∏è Tags: {len(video_info.get('tags', []))} tags")
            print(f"   üìù M√¥ t·∫£: {len(video_info.get('description', ''))} k√Ω t·ª±")
            print(f"   üîó URL: {video_info['webpage_url']}")
            
            # X√°c nh·∫≠n download
            print("\n" + "-"*40)
            confirm = input("‚ùì Ti·∫øp t·ª•c download v√† t·∫°o TikTok content? (y/n): ").strip().lower()
            if confirm != 'y':
                print("üö´ ƒê√£ h·ªßy thao t√°c")
                return False
            
            # Download video
            print("\nüîç GIAI ƒêO·∫†N 2: DOWNLOAD VIDEO")
            print("-"*40)
            quality_format = self.quality_options[quality_choice]['format']
            quality_name = self.quality_options[quality_choice]['name']
            print(f"üéØ Ch·∫ø ƒë·ªô download: {quality_name}")
            
            video_file = self.download_video(url, output_folder, quality_format, video_info)
            
            if not video_file:
                print("‚ùå Download th·∫•t b·∫°i")
                return False
            
            # T·∫°o TikTok content
            print("\nüîç GIAI ƒêO·∫†N 3: T·∫†O TIKTOK CONTENT")
            print("-"*40)
            print("ü§ñ Kh·ªüi ƒë·ªông content generator...")
            print("üìä ƒêang ph√¢n t√≠ch n·ªôi dung video...")
            
            content_success = self.content_generator.generate_tiktok_content(
                video_info, video_file, output_folder
            )
            
            if content_success:
                print("\n" + "="*70)
                print("üéâ HO√ÄN TH√ÄNH TH√ÄNH C√îNG!")
                print("="*70)
                print("‚úÖ Video ƒë√£ ƒë∆∞·ª£c download")
                print("‚úÖ TikTok content ƒë√£ ƒë∆∞·ª£c t·∫°o")
                print(f"üìÅ T·∫•t c·∫£ files ƒë√£ l∆∞u trong: {output_folder}")
                print("üí° B·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng content ƒë·ªÉ ƒëƒÉng TikTok ngay!")
            else:
                print("\n‚ö†Ô∏è Video download th√†nh c√¥ng nh∆∞ng c√≥ l·ªói t·∫°o content TikTok")
            
            return True
            
        except Exception as e:
            print(f"\n‚ùå L·ªói x·ª≠ l√Ω: {e}")
            import traceback
            print(f"üîç Chi ti·∫øt l·ªói: {traceback.format_exc()}")
            return False
    
    def execute(self, input_folder, output_folder):
        """Th·ª±c thi ch·ª©c nƒÉng YouTube downloader v·ªõi complete logging"""
        print("\n" + "="*80)
        print("üé¨ YOUTUBE TO TIKTOK CONTENT GENERATOR")
        print("üì∫ VideoForge Professional Video Processing Suite")
        print("="*80)
        
        # Ki·ªÉm tra dependencies
        print("\nüîç B∆Ø·ªöC 1: KI·ªÇM TRA H·ªÜ TH·ªêNG")
        print("-"*50)
        print("üîß ƒêang ki·ªÉm tra dependencies...")
        
        if not self.check_dependencies():
            print("‚ùå System check th·∫•t b·∫°i!")
            print("\nüí° H∆Ø·ªöNG D·∫™N C√ÄI ƒê·∫∂T:")
            print("pip install yt-dlp")
            print("pip install openai-whisper")
            print("\nüîÑ Sau khi c√†i ƒë·∫∑t, h√£y ch·∫°y l·∫°i ch·ª©c nƒÉng n√†y")
            input("Nh·∫•n Enter ƒë·ªÉ ti·∫øp t·ª•c...")
            return
        
        print("‚úÖ yt-dlp library ƒë√£ s·∫µn s√†ng")
        print("‚úÖ System requirements OK")
        
        # Ki·ªÉm tra th∆∞ m·ª•c output
        print("\nüîç B∆Ø·ªöC 2: KI·ªÇM TRA TH∆Ø M·ª§C")
        print("-"*50)
        print("üìÅ ƒêang ki·ªÉm tra th∆∞ m·ª•c output...")
        
        if not output_folder:
            print("‚ùå Th∆∞ m·ª•c output ch∆∞a ƒë∆∞·ª£c thi·∫øt l·∫≠p!")
            print("üí° Vui l√≤ng ch·ªçn menu '10. ‚öôÔ∏è Thay ƒë·ªïi th∆∞ m·ª•c Input/Output' tr∆∞·ªõc")
            input("Nh·∫•n Enter ƒë·ªÉ ti·∫øp t·ª•c...")
            return
        
        print(f"‚úÖ Th∆∞ m·ª•c output: {output_folder}")
        
        if not os.path.exists(output_folder):
            try:
                print("üìÅ Th∆∞ m·ª•c ch∆∞a t·ªìn t·∫°i, ƒëang t·∫°o...")
                os.makedirs(output_folder)
                print(f"‚úÖ ƒê√£ t·∫°o th∆∞ m·ª•c: {output_folder}")
            except Exception as e:
                print(f"‚ùå Kh√¥ng th·ªÉ t·∫°o th∆∞ m·ª•c output: {e}")
                input("Nh·∫•n Enter ƒë·ªÉ ti·∫øp t·ª•c...")
                return
        else:
            print("‚úÖ Th∆∞ m·ª•c output ƒë√£ t·ªìn t·∫°i")
        
        # Ki·ªÉm tra quy·ªÅn ghi
        print("üîê ƒêang ki·ªÉm tra quy·ªÅn ghi file...")
        try:
            test_file = os.path.join(output_folder, "test_write.tmp")
            with open(test_file, 'w') as f:
                f.write("test")
            os.remove(test_file)
            print("‚úÖ Quy·ªÅn ghi file OK")
        except Exception as e:
            print(f"‚ùå Kh√¥ng c√≥ quy·ªÅn ghi v√†o th∆∞ m·ª•c: {e}")
            input("Nh·∫•n Enter ƒë·ªÉ ti·∫øp t·ª•c...")
            return
        
        # Main loop
        session_count = 0
        success_count = 0
        
        print(f"\nüéØ H·ªÜ TH·ªêNG S·∫¥N S√ÄNG!")
        print(f"üìÅ Files s·∫Ω ƒë∆∞·ª£c l∆∞u v√†o: {output_folder}")
        print("-"*80)
        
        while True:
            session_count += 1
            
            print(f"\nüé¨ SESSION #{session_count}")
            print("="*60)
            print(f"üìä Th·ªëng k√™: {success_count} video ƒë√£ x·ª≠ l√Ω th√†nh c√¥ng")
            print(f"üìÅ Th∆∞ m·ª•c l∆∞u: {output_folder}")
            print("-"*60)
            
            # Nh·∫≠p YouTube URL
            url = input("üîó Nh·∫≠p URL YouTube (ho·∫∑c 'q' ƒë·ªÉ tho√°t): ").strip()
            
            if url.lower() == 'q':
                break
            
            if not url:
                print("‚ö†Ô∏è URL tr·ªëng, vui l√≤ng nh·∫≠p l·∫°i")
                continue
            
            print(f"\nüîç B∆Ø·ªöC 3: VALIDATE URL")
            print("-"*40)
            print(f"üîó URL nh·∫≠n ƒë∆∞·ª£c: {url}")
            print("üîç ƒêang ki·ªÉm tra format URL...")
            
            # Validate URL
            if not self.validate_youtube_url(url):
                print("‚ùå URL kh√¥ng h·ª£p l·ªá!")
                print("üí° ƒê·ªãnh d·∫°ng h·ªó tr·ª£:")
                print("   - https://www.youtube.com/watch?v=VIDEO_ID")
                print("   - https://youtu.be/VIDEO_ID")
                print("   - youtube.com/watch?v=VIDEO_ID")
                continue
            
            print("‚úÖ URL format h·ª£p l·ªá")
            print("‚úÖ ƒê√£ x√°c nh·∫≠n l√† YouTube URL")
            
            # Hi·ªÉn th·ªã menu ch·∫•t l∆∞·ª£ng
            print(f"\nüîç B∆Ø·ªöC 4: CH·ªåN CH·∫§T L∆Ø·ª¢NG")
            print("-"*40)
            self.show_quality_menu()
            quality_choice = self.get_quality_choice()
            
            if quality_choice is None:
                print("üö´ ƒê√£ h·ªßy ch·ªçn ch·∫•t l∆∞·ª£ng")
                continue
            
            quality_name = self.quality_options[quality_choice]['name']
            print(f"‚úÖ ƒê√£ ch·ªçn: {quality_name}")
            
            # B·∫Øt ƒë·∫ßu processing
            print(f"\nüöÄ B∆Ø·ªöC 5: B·∫ÆT ƒê·∫¶U X·ª¨ L√ù")
            print("-"*40)
            print(f"‚è∞ Th·ªùi gian b·∫Øt ƒë·∫ßu: {datetime.now().strftime('%H:%M:%S')}")
            
            # X·ª≠ l√Ω download v√† t·∫°o content
            start_time = datetime.now()
            success = self.process_youtube_url(url, output_folder, quality_choice)
            end_time = datetime.now()
            
            processing_time = (end_time - start_time).total_seconds()
            
            if success:
                success_count += 1
                print(f"\nüéâ SESSION #{session_count} HO√ÄN TH√ÄNH!")
                print("="*60)
                print(f"‚úÖ Th·ªùi gian x·ª≠ l√Ω: {processing_time:.1f} gi√¢y")
                print(f"‚úÖ Video v√† content ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng")
                print(f"üìÅ Location: {output_folder}")
                
                # List files ƒë∆∞·ª£c t·∫°o
                print(f"\nüìã FILES T·∫†O TRONG SESSION #{session_count}:")
                recent_files = []
                for file in os.listdir(output_folder):
                    file_path = os.path.join(output_folder, file)
                    file_time = os.path.getctime(file_path)
                    if datetime.fromtimestamp(file_time) >= start_time:
                        recent_files.append(file)
                
                for file in sorted(recent_files):
                    file_path = os.path.join(output_folder, file)
                    file_size = os.path.getsize(file_path)
                    if file_size > 1024*1024:
                        size_str = f"{file_size/(1024*1024):.1f}MB"
                    elif file_size > 1024:
                        size_str = f"{file_size/1024:.1f}KB"
                    else:
                        size_str = f"{file_size}B"
                    
                    if file.endswith('.mp4') or file.endswith('.mkv') or file.endswith('.webm'):
                        print(f"   üé¨ {file} ({size_str})")
                    elif file.endswith('.txt'):
                        print(f"   üìÑ {file} ({size_str})")
                    elif file.endswith('.json'):
                        print(f"   üìä {file} ({size_str})")
                    else:
                        print(f"   üìÅ {file} ({size_str})")
                
                # H·ªèi c√≥ mu·ªën download th√™m kh√¥ng
                another = input(f"\n‚ùì Download video kh√°c? (y/n): ").strip().lower()
                if another != 'y':
                    break
            else:
                print(f"\n‚ùå SESSION #{session_count} TH·∫§T B·∫†I!")
                print("="*60)
                print(f"‚è±Ô∏è Th·ªùi gian th·ª≠: {processing_time:.1f} gi√¢y")
                print("üí° G·ª£i √Ω kh·∫Øc ph·ª•c:")
                print("   - Ki·ªÉm tra k·∫øt n·ªëi internet")
                print("   - Th·ª≠ URL kh√°c")
                print("   - Ch·ªçn ch·∫•t l∆∞·ª£ng th·∫•p h∆°n")
                print("   - Ki·ªÉm tra video c√≥ b·ªã private kh√¥ng")
                
                retry = input("\n‚ùì Th·ª≠ l·∫°i v·ªõi URL kh√°c? (y/n): ").strip().lower()
                if retry != 'y':
                    break
        
        # Session summary
        print(f"\nüìä T·ªîNG K·∫æT SESSION")
        print("="*80)
        print(f"üé¨ T·ªïng s·ªë video ƒë√£ x·ª≠ l√Ω: {success_count}/{session_count}")
        if success_count > 0:
            success_rate = (success_count / session_count) * 100
            print(f"üìà T·ª∑ l·ªá th√†nh c√¥ng: {success_rate:.1f}%")
            print(f"üìÅ T·∫•t c·∫£ files ƒë√£ l∆∞u trong: {output_folder}")
            print(f"üí° B·∫°n c√≥ {success_count} TikTok content s·∫µn s√†ng s·ª≠ d·ª•ng!")
        
        print(f"‚è∞ K·∫øt th√∫c session: {datetime.now().strftime('%H:%M:%S')}")
        print("\nüëã C·∫£m ∆°n b·∫°n ƒë√£ s·ª≠ d·ª•ng YouTube Downloader!")
        print("üéâ Ch√∫c b·∫°n viral tr√™n TikTok!")
        input("Nh·∫•n Enter ƒë·ªÉ quay v·ªÅ menu ch√≠nh...")